package ru.netology;


public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1

        //Что происходит: Переменная примитивного типа i объявляется и инициализируется значением 1.
        //Где хранится значение: Значение переменной сохраняется в стеке (stack), поскольку это локальная переменная.
        //ClassLoader: Эта инструкция выполняется в основном классе JvmComprehension, загруженном загрузчиком класса AppClassLoader.

        Object o = new Object();        // 2

        //Что происходит: Создается новый экземпляр объекта Object, который является родителем всех классов в Java.
        //Где хранятся значения: Объект создается в куче (heap), ссылка на этот объект сохраняется в стеке.
        //Сборка мусора: Пока существует хотя бы одна действующая ссылка на объект (переменная o), сборщик мусора (GC) не сможет удалить объект из памяти.
        //ClassLoader: Классы Object и JvmComprehension загружены загрузчиками Boot Class Loader и AppClassLoader соответственно.

        Integer ii = 2;                 // 3

        //Что происходит: Объявляется новая переменная типа-обёртки Integer, присваивается ей значение 2.
        //Где сохраняются значения: Так как число маленькое (от -128 до 127), используется механизм кеширования целых чисел, встроенных в классы-обертки. Поэтому здесь не выделяется память в heap для нового объекта, а возвращается ссылка на существующий в постоянном пуле объектов Integer.
        //Сборка мусора: Поскольку объекты из диапазона -128..127 постоянно кэшируются, они остаются в постоянной области хранения и сборщику мусора ничего удалять не потребуется.
        //ClassLoader: Класс Integer загружается Bootstrap Classloader, так как входит в стандартные пакеты платформы Java.

        printAll(o, i, ii);             // 4

        //Что происходит: Метод printAll() вызывается с передачей аргументов.
        //Класс загрузки: Метод вызывается из основного класса JvmComprehension, загруженного AppClassLoader.
        //Стековая структура: Когда вызывается метод, на стек добавляется новый фрейм (frame), содержащий аргументы переданные в метод (o, i, ii) и область видимости методов.

        System.out.println("finished"); // 7

        //Что происходит: Простой вывод текста на стандартный вывод.
        //Память: Нет выделения дополнительной памяти, так как строка "finished" константа и уже размещена в пул строк (string pool) в MetaSpace.
        //ClassLoader: Опять же методы стандартной библиотеки, загруженные Bootstrap Classloader’ом.

    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5

        //Что происходит: Новое целочисленное значение оборачивается объектом Integer.
        //Где хранится: Создание объекта происходит в куче (heap), а ссылка на объект — в стеке (local variables section of the current stack frame).
        //Сборка мусора: После завершения метода printAll(), эта переменная станет доступной для сбора мусора, так как больше ссылок на неё не останется.

        System.out.println(o.toString() + i + ii);  // 6

        //Что происходит: Происходит конкатенация строки и двух значений типов int и Integer.
        //Memory Usage: Результат вычислений (строка) временно хранит промежуточное состояние в специальной структуре String Builder, а итоговая строка размещается в куче.
        //Методы ClassLoader: Методы стандартной библиотеки (таких как toString(), println()) находятся в bootstrap-классах и загружены Bootstrap Classloader’ом.
    }
}
